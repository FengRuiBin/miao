 <script>
 function S(n) {
   if (n == 1) {
     return a(1)
   }
     else {
       return a(n) + S(n - 1)
     }
 }
</script>

<script>
  function f(n) {
    if (n < 3) {
      return 1
    }
      else {
        return f(n - 1) + f(n - 2)
      }
  }
</script>

<script>
  function fill(ary, value, start = 0, end = ary.length) {
    for (var i = start; i < end; i++) {
      ary[i] = value

    }
  }
</script>

<script>
  function createListNode(val) {
    return {
      val: val,
      next: null,
    }
  }

  function arrayToList(array) {

  }
</script>

<script>
  function nth(head,n) {
    var x = head
    for (var i = 0; i < head.length; i++){
      n = head[i] 
    }
    return n


  }
</script> 

<script>
  function reduce(array, test) {
    var result = []
    for (var i = 0; i < array.length; i++) {
      if (test(array[i], i) === true) {
        result.push(array[i])

      }
    }
    return result 
  }
</script>

<script>
  function flatten(arrays) {
    attay.reduce()
    var result = []
    for (var i = 0; i < arrays.length; i++) {
      var item = array[i]
      if (Array.isArray(item)) {
        for (var j = 0; j < item.length; j++) {
          result.push(item[j])
        }
      } else {
        result.push(item)
      }
    }
    return result
  }
  result = result.concat(array[i])
</script>

<script>
  //f接收数组中的项，返回该项应该在的组名
  //整个函数返回一个对象，对象的key为组名，value为这个组里的元素们
  function groupBy(array, f){

  }
</script>

<script>
  //判断数组中的每一项是都满足test函数
  function every(array, test) {
    for (var i = 0; i < array.length; i++) {
      if (test(array[i], i)) {
      }
    }
  }
</script>

<script>
  function bubbleSort(array) {//冒泡排序
    for (var j = 0; j < array.length - 1; j++) {//外层循环，假设最大数在最左边，只需移动（-1次）
      var swapped = false//交换为假
      for (var i = 0; i < array.length - 1 - j; i++) {//内层循环，假设最大数在最左边（-1次，每次最后一个数不用移动）
        if (array[i] > array[i + 1]) {//假如前面数大于后面数往后移动
          swapped = true//交换为真
          var t = array[i]
          array[i] = array[i + 1]
          array[i + 1] = t
        }
        if (!swapped) {//假如没有交换位置
          break
        }
      }
    }
    return array
  }
</script>

<script>
  function selectSort(array) {//选择排序
    for (var i = 0; i < array.length - 1; i++) {
      var minIdx = i
      for (var j = i + 1; j < array.length; j++) {
        if (array[j] < array[minIdx]) {
          min = j
        }
      }
      var t = array[i]
      array[i] = array[minIdx]
      array[minIdx] = t
    }
    return array
  }
</script>

<script>
  function insertSort(array) {
    for (var i = 1; i < array.length; i++) {//第0位先不用移动，所以从第1位开始取出移动
      var t =  array[i]
      for (var j = i - 1; j >= 0; j--) {//把前面的数往后移动
        if (array[j] > t ) {
          array[j + 1] = array[j]//j项往前移动
        } else {
          break
        }
      }
      array[j + 1] = t
    }
    return array
  }
</script>

<script>
  function mergeSort(array) {
    if (array,length < 2) {
      return array
    }//结束条件
    var minIdx = array.length >> 1//数组一分为二
    var leftArray = array.slice(0, midIdx)
    var rightArray = array.slice(midIdx)
    leftArray = mergeSort(leftArray)//已经有序 递归
    rightArray = mergeSort(rightArray)//已经有序 递归
    var i = 0
    var j = 0
    var k = 0
    while (i < leftArray.length && j < rightArray.length) {
      if (leftArray[i] < rightArray[j]) {
        array[k++] = leftArray[i++]
      } else {
        array[k++] = rightArray[j++]
      }
    }
    while (i < leftArray.length) {
      array[k++] = leftArray[i++]
    }
    while (j < rightArray.length) {
      array[k++] = rightArray[j++]
    }
    return array
  }
</script>

<script>
  /*
  function quickSort(array) {
    if (array, length < 2) {
      return array
    }//结束条件
    var randIdx = Math.floor(Math.random()//随机数 * array.length)//随机选一个数下取整
    var randItem = array[randIdx]//随机数标记为一个数组
    var a = []//所有小于randItem的元素
    var b = []//所有等于randItem的元素
    var c = []//所有大于染得Item的元素；分为a，b，c三个数组
    for (var i = 0; i < array.length; i++) {//遍历数组
      if (array[i] < randItem) {
        a.push(array[i])
      } else if (array[i] > randItem) {
        c.push(array[i])
      } else {
        b.push(array[i])
      }
    }
    a = quickSort(a)//递归
    c = quickSort(c)//递归
    return a.concat(b, c)
  }
  */


  //对数组中start到end（包含）范围内的数执行快速排序
  function quickSort(array, start = 0, end = array.length - 1) {
    if (end - start < 1) {
      return array
    }//结束条件
    var pivotIdx = Math.floor(Math.random() * (end - start + 1)) + start//随机选一个数下取整
    var pivot = array[pivotIdx]
    swap(array, pivotIdx,end)//随机数交换到末尾
    var j = start
    var i = start//初始化2个数指向数组开头
    for (; j < end; j++) {//用j遍历这个范围
      if (array[j] < pivot) {//如果遇到一个数j比随机数小
        swap(array, i++, j)//把i加一和j换位置
      }
    }
    swap(array, i, end)//把i和最末尾的数交换位置
    quickSort(array, start, i - 1)//继续执行操作
    quickSort(array, i + 1, end)//继续执行操作
    return array
  }
</script>

<script>
  function isSorted(array) {//检查数组是否有序
    for (var i = 0; i < array.length - 1; i++) {
      if (array[i] > array[i + 1]) {
        return false
      }
    }
    return true
  }
</script>

<script>
/*  排序算法的稳定性：排序前后相同元素的相对位置有没有发生变化。
      稳定的排序算法：
        冒泡排序
        插入排序
        归并排序
        二叉排序

      不稳定的排序算法：
        选择排序
        快速排序
        堆排序

    稳定性的一个重要应用就是多级排序（类似成绩单：总分相同按语文排，以此类推）
*/
</script>